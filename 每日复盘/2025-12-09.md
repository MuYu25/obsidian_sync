## **今天完成了什么？值得肯定的地方是什么？**（目的：建立信心，看到进步，而不是只盯着没做完的事）
- 今天把需求写的差不多了，
	- 玩法配置信息的配置
	- 软件下载包的链接
- 今天253测试数据库还崩了，详细看[[../工作中的小意外/2025-12-09|2025-12-09]]
## **今天有什么事情可以做得更好？卡点在哪里？**（目的：发现问题，但不是自责。例如：“沟通时没先确认对方需求，导致返工”）
- 今天遇到一个并发问题导致返工，前端会在新增或者删除后立马查询一次数据。在并发的情况下是可能查到旧数据的。问同事的解决方案是添加`delete_at`,效果暂时是有的。再详细一点的，我明天再测试。
## **基于以上，我明天可以立即尝试的一个小改进是什么？**（目的：将复盘转化为行动。例如：“明天开会前，先花2分钟写下核心目标和问题”）
- 留意数据记得添加`delete_at`，特别是这种`orm`框架。AI是这样解释的。
- 逻辑删除之所以更可靠地解决这个时序问题，有以下几个因素：
1. **缓存一致性 ($\text{Cache Consistency}$):**
    - $\text{DELETE}$ 操作涉及从数据库和可能的缓存中**移除**记录。
    - $\text{UPDATE}$ 操作只是**修改**记录的一个字段，它通常只会导致数据库缓存**更新该行记录**。在高并发下，$\text{UPDATE}$ 操作的事务提交和数据对后续查询的可见性通常比 $\text{DELETE}$ 的**原子性移除**操作更快、更可预测。
2. **数据库操作的复杂度 ($\text{Database Complexity}$):**
    - 在一些存储引擎中，$\text{DELETE}$ 可能会涉及更复杂的**索引清理**和**数据页重组**（虽然通常是异步执行），但 $\text{UPDATE}$ 只是修改一行，操作更加集中和快速。
3. **应用层保证 ($\text{Application Guarantee}$):**
    - 最重要的是，$\text{deleted\_at}$ 机制是将**可见性控制权**从**数据库事务提交时间**，转移到了**后端查询逻辑**（$\text{WHERE deleted\_at IS NULL}$）上。
    - 只要 $\text{UPDATE}$ 事务提交，这条数据就**立刻**（或在极短时间内）对所有后续的**查询逻辑**变得**不可见**，从而消除了时序竞争。