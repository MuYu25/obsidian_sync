## **今天完成了什么？值得肯定的地方是什么？**（目的：建立信心，看到进步，而不是只盯着没做完的事）
- 今天上午发现了昨天的报错,查询`count`时报错（在我印象中根本不可能,没查到长度就是0），报错的代码如下 ：
```GO
count, err := dao.StatDailyAdIncome.Ctx(ctx).Where(dao.StatDailyAdIncome.Columns().Date, req.Date).Where(dao.StatDailyAdIncome.Columns().AppId, appId).Count()
if err != nil {
	g.Log().Errorf(ctx, "查询日期%s 的数据失败: %v", req.Date, err)
	return nil, errors.New("查询数据失败")
}
```
原因是正式数据库还没有添加`appId`字段导致的。
- 今天还看完了用户`近5天的ecpm`值优化，没动之前的设计为什么慢，说查询用户近五天内的`eCPM`值慢(之前为什么慢没看懂),目的是优化`每个用户近5天的ecpm值查询`，之前还和同事调侃了一个方案，是每个应用分一个数据库，然后每个用户分一张表笑死。(因为怕每日统一时间更新会出现锁表的情况，严重影响并发).
- 现在的解决方案是使用`redis存双向队列`,数据都设置`7天的过期时间`,每日更新时，将最远的一条数据删除，然后计算新的数据并且加入`队列`，其中`LPUSH, LTRIM, EXPIRE, LRANGE`使用`lua`维持这些命令的原子性，下面贴一些`lua`的代码，很简单，但是怕忘记，没事看看。
```go
script := `
	redis.call("LPUSH", KEYS[1], ARGV[1])
	redis.call("LTRIM", KEYS[1], 0, 4)
	redis.call("EXPIRE", KEYS[1], ARGV[2])
	return redis.call("LRANGE", KEYS[1], 0, -1)
`
// 执行脚本， 1是指key的数量，key也可以有多个。
resultVar, err := rdb.Do(ctx, "EVAL", script, 1, redisKey, newEcpm, EcpmWindowCacheTTL)
```

```go
script := `
	redis.call("DEL", KEYS[1])
	for i, v in ipairs(ARGV) do
		if i > 1 then
			redis.call("RPUSH", KEYS[1], v)
		end
	end
	redis.call("EXPIRE", KEYS[1], ARGV[1])
	return "OK"
 `
 // 执行脚本 args[0]存放的是过期时间。后面的才是数据。
if _, err := rdb.Do(ctx, "EVAL", script, 1, key, args); err != nil {
	logger.Errorf(ctx, "Redis Lua(LoadHistory) failed: %v", err)
	return errors.New("系统繁忙")
}
```
## **今天有什么事情可以做得更好？卡点在哪里？**（目的：发现问题，但不是自责。例如：“沟通时没先确认对方需求，导致返工”）
## **基于以上，我明天可以立即尝试的一个小改进是什么？**（目的：将复盘转化为行动。例如：“明天开会前，先花2分钟写下核心目标和问题”）
- `count`确实大多数就是不太可能报错的，除非语句出现了问题，才可能报错。下次留意。可以省自己的时间。