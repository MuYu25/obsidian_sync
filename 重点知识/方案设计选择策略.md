# 抽象问题类型
两种设计方案中的优与劣比较，主要从哪些方面进行比较，能够快速的得出优劣性的结论。
# 具体问题
> 需求：做一个竞猜奖池，每20分钟结算一次。公布开奖结果并更新用户竞猜状态

在设计之初就存在两种方案
1. `方案1`:每20分钟扫描一次`guess_log`表，直接对表中的数据进行结算。其他表只表示额外数据
2. `方案2`:结算以`guess_pool`表为主，每次在`guess_pool`中查找当期结算的所有用户并且结算。
先说结论，一定是`方案1`是最优解。
# 主要方案优劣性分析

## 分析角度

### 单一事实原则(Single Source of Truth)
问题：一旦出现数据不一致的情况，该信谁？
-  `方案1`: `guess_log`中即时记录也是事实，`guess_log`有就是投了，没有就是没投。
- `方案2`: 如果不小心写了`guess_log`但是没更新`guess_pool`，就得写复杂的补偿代码来修复数据。
**决策点：** 永远优先选择**不需要维护两份数据一致性**的方案，`log` (流水)永远是核心。

### 热点行原则(Hot Row Contention)
问题：高并发写入时，大家是不是在抢同一把锁？
- `方案1`：用户 A 下注，Insert 一行；用户 B 下注，Insert 另一行。互不干扰。数据库最喜欢 Insert 操作（Append Only）。**（优）**
- `方案2`：用户 A 和 B 都要去修改 `pool_info` 表的**同一行**（把自己的 ID 加进去）。数据库不得不对这一行加锁（Row Lock）。哪怕是 Redis，更新一个巨大的 Set 也是有成本的。
**决策点：** **避免“多对一”的更新**。如果有 1 万人同时操作，方案 1 是 1 万条并行车道，方案 2 是 1 万辆车挤 1 个收费站。

### 读写频率原则 (Read/Write Ratio)
问题：这个数据是`写多读少`还是`读多写少`？
竞猜业务的特征是：**平时疯狂写**（20分钟内大家都在下注），**最后只读一次**（结算那一刻）。
- **方案1**：完美契合。写入时飞快（Insert），读取时虽然要聚合，但只有一次。
- **方案2**：写入时很痛苦（要更新大字段），读取时虽然稍微方便点，但为了那一次读取的方便，牺牲了成千上万次写入的性能，得不偿失。
**决策点：** 针对“高频写入”的业务，尽量把计算压力推迟到“读取/结算”阶段，而不是在写入阶段就做复杂的聚合。

### 内存爆炸原则 (Memory Bloat)
问题：如果数据量扩大 100 倍，内存存的下吗？
- **方案1**：你在 Golang 中处理时，可以使用 `LIMIT/OFFSET` 或者 `Cursor` 分批读。每次内存里只放 1000 条，处理完 100 万条也没压力。**（优）**
- **方案2**：如果那个 ID 列表里有 100 万个 ID，你从数据库读出来的那一瞬间，Golang 进程的内存会瞬间飙升（大对象分配）。如果同时结算 10 个池子，可能会 OOM (Out of Memory)。
**决策点：** 能够**流式(Stream)** 处理的方案 > 必须一次性全量加载的方案。

### 业务弹性原则 (Extensibility)
问题：如果业务逻辑变了，数据结构能抗住吗？
- **方案1**：需求变更：“我们要统计某个用户在某期的总下注额”。SQL: `SELECT sum(amount) ... GROUP BY user_id`。直接查就行，不用改表。
- **方案2**：需求变更：“同上”。完蛋了，池子里只存了 `[id1, id2...]`，没有存金额。你得先解析 ID，再一个个去查 Log。或者你得修改池子结构存 `[{id:1, amt:100}, ...]`，这就是“痛苦”。
**决策点：** **原子化存储 (Atomic Storage)** 优于 **聚合存储 (Aggregated Storage)**。存得越细，组合查询越灵活。

# 总结
下次再有类似纠结，直接问自己：**“我在写入时是不是在抢锁？我在读取时能不能分批？”** 如果答案是“在抢锁”且“不能分批”，直接 Pass 掉。