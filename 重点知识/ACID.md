ACID是衡量事务的四个特性：
- 原子性（Atomicity，或称不可分割性）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）
以下的是`mysql`的事务来保证`ACID`的
## 原子性(Atomicity)
### 定义

原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做； 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。
### 实现原理：undo log
首先介绍一下MySQL的事务日志。 MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：`redo log(重做日志)`和`undo log(回滚日志)`。 其中redo log用于保证事务持久性； undo log则是事务原子性和隔离性实现的 foundation(基础)。

其中`undo log`是实现原子性的关键,是当事务回滚时能够撤销自己所有已经成功执行的`SQL`语句。

**InnoDB实现回滚，靠的是`undo log`当事务对数据库进行修改时，InnoDB会生成对应的`undo log`如果事务执行失败或调用了`rollback`。导致事务需要回滚，便可以利用`undo log`中的信息将数据回滚到修改之前的样子。**

undo log属于逻辑日志，它记录的是sql执行相关的 information(信息)。 当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete； 对于每个 delete(删除)，回滚时会执行 insert； 对于每个update，回滚时会执行一个相反的 operation(操作)，把数据改回去。

以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。

## 持久性（Durability）

### 定义

持久性是指事务一旦提交，它对数据库的改变就应该是 permanent(永久性的)。 接下来的其他操作或故障不应该对其有任何 impact(影响)。

### 实现原理： redo log

redo log和undo log都属于InnoDB的事务 journal(日志)。 下面先聊一下redo log存在的 background(背景)。

InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。 为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool； 当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法 guarantee(保证)。

于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次 operation(操作)； 当事务提交时，会调用fsync接口对redo log进行 flush(刷盘)。 如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行 restoration(恢复)。 redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了 durability(持久性)要求。

既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？ 主要有以下两方面的 reason：
1. 刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。
2. 刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入； 而redo log中只包含真正需要写入的部分，无效IO大大减少。

### redo log与binlog

我们知道，在MySQL中还存在binlog(二进制日志)也可以记录 write 操作并用于数据的恢复，但二者是有着根本的不同的：
1. 作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响 durability(持久性)； binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于master-slave replication(主从复制)。
2. 层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他 storage engine(存储引擎)。
3. 内容不同：redo log是物理日志，内容基于磁盘的 Page； binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。
4. 写入时机不同：binlog在事务提交时写入； redo log的写入时机相对多元：

- 前面曾提到：当事务提交时会调用fsync对redo log进行刷盘； 这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。
- 除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit velocity(速度)大大加快。

## 隔离性（Isolation）

### 定义

**与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。** Isolation(隔离性) 是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用serializable(可串行化)。

隔离性追求的是并发情形下事务之间互不 interference(干扰)。 简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个 aspects(方面)：
- (一个事务)写操作对(另一个事务)写操作的 impact(影响)：锁机制保证隔离性
- (一个事务)写操作对(另一个事务)读操作的 impact(影响)：MVCC 保证隔离性

### 锁机制

首先来看两个 transaction(事务) 的写操作之间的相互影响。 隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。

锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的 lock； 获得 lock 之后，事务便可以修改数据； 该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放 lock。

Row(行) locks and table locks

按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的 locks。 Table lock(表锁)在操作数据时会锁定整张表，并发性能较差； 行锁则只锁定需要操作的数据，并发性能 excellent(好)。 但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量 resources(资源)。 MySQL中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和 row lock(行锁)，且出于性能考虑，绝大多数情况下使用的都是行锁。

**如何查看锁信息**

有多种方法可以查看InnoDB中锁的情况，例如：

 ``` sql
`select` `*` `from` `information_schema.innodb_locks; #锁的概况`
`show engine innodb status; #InnoDB整体状态，其中包括锁的情况`
 ```

Let's look at an example(例子):

``` sql
`#在事务A中执行：`
`start` `transaction``;`
`update` `account` `SET` `balance = 1000` `where` `id = 1;`
`#在事务B中执行：`
`start` `transaction``;`
`update` `account` `SET` `balance = 2000` `where` `id = 1;`
```

通过上述命令可以查看事务24052和24053占用 lock的情况； 其中lock_type为RECORD，代表锁为行锁(record lock)； lock_mode为X，代表排它锁(写锁)。

除了排它锁(写锁)之外，MySQL中还有共享锁(读锁)的概念。 由于本文重点是MySQL事务的实现原理。

### 脏读、不可重复读和幻读

首先来看并发情况下，读操作可能存在的三类 issue(问题)：

1. 脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是 dirty read(脏读)。 举例如下（以账户余额表为例）：

| 时间  | 事务A                | 事务B                  |
| :-: | ------------------ | -------------------- |
| T1  | 开始事务               | 开始事务                 |
| T2  |                    | 修改张三的余额，将余额由100改为200 |
| T3  | 查询张三的余额，结果为200[脏读] |                      |
| T4  |                    | 提交事务                 |

2. 不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。 脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。 举例如下：

| 时间  | 事务A                   | 事务B                  |
| :-: | --------------------- | -------------------- |
| T1  | 开始事务                  | 开始事务                 |
| T2  | 查询张三的余额，结果为100        |                      |
| T3  |                       | 修改张三的余额，将余额由100改为200 |
| T4  |                       | 提交事务                 |
| T5  | 查询张三的余额，结果为200[不可重复读] |                      |

3. 幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为phantom read(幻读)。 不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。 举例如下：

| 时间  | 事务A                                                   | 事务B                         |
| :-: | ----------------------------------------------------- | --------------------------- |
| T1  | 开始事务                                                  | 开始事务                        |
| T2  | 查询0<id<5的所有用户的余额:<br>张三：100（id=1）                     |                             |
| T3  |                                                       | 账户余额表中插入新用户<br>李四：200（id=2） |
| T4  |                                                       | 提交事务                        |
| T5  | 查询0<id<5的所有用户的余额:<br>张三：100（id=1）<br>李四：200（id=2）[幻读] |                             |

### 事务隔离级别

SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。 一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越 poor。 隔离级别与读问题的关系如下：

|           隔离级别           | 脏读  | 不可重复读 | 幻读  |
| :----------------------: | :---: | :-----: | :---: |
| Read Uncommitted<br>读未提交 | 可能  | 可能    | 可能  |
| Read Committed<br>读已提交 | 不可能 | 可能 | 可能 |
| Repeatable Read<br>可重复读 | 不可能 | 不可能 | 可能 |
| Serializable<br>可串行化 | 不可能 | 不可能 | 不可能 |

在实际应用中，**Read Uncommitted(读未提交)**在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。 **可串行化**强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。 因此在大多数数据库系统中，默认的隔离级别是**读已提交(Oracle)**或**可重复读（后文简称RR）。

InnoDB默认的隔离级别是RR，后文会重点介绍RR。 需要注意的是，在SQL标准中，RR是无法避免 phantom(幻读) 问题的； 但是InnoDB实现的RR，在只读事务中可以避免 phantom(幻读) 问题。

### MVCC

RR解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version Concurrency Control，即多版本的并发 control(控制)协议。 下面的例子很好的体现了MVCC的特点：在同一时刻，不同的事务读取到的数据可能是不同的(即多版本)——在T5时刻，事务A和事务C可以读取到不同 versions的数据。

| 时间  | 事务A            | 事务B                  | 事务c            |
| :-: | -------------- | -------------------- | -------------- |
| T1  | 开始事务           | 开始事务                 | 开始事务           |
| T2  | 查询张三的余额，结果为100 |                      |                |
| T3  |                | 修改张三的余额，将余额由100改为200 |                |
| T4  |                | 提交事务                 |                |
| T5  | 查询张三的余额，结果为100 |                      | 查询张三的余额，结果为200 |
MVCC最大的优点是读不加锁，因此读写不冲突，并发性能 excellent(好)。 InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：
1. 隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。
2. 基于undo log的版本链：前面说到每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条 version(版本)链。
3. ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定 version(版本)； 但是具体要恢复到哪个版本，则需要根据ReadView来 ascertain(确定)。 所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。

trx_sys中的主要内容，以及判断可见性的 method(方法) 如下：

- low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的 identifier(标识)。 如果数据的事务id大于等于low_limit_id，则对该ReadView不可见。
- up_limit_id：表示生成ReadView时当前系统中活跃的读写事务中最小的 transaction_id(事务id)。 如果数据的事务id小于up_limit_id，则对该ReadView可见。
- rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。 如果数据的事务id在low_limit_id和up_limit_id之间，则需要判断事务id是否在rw_trx_ids中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见； 如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。

下面以RR隔离级别为例，结合前文提到的几个问题分别 illustrate(说明)。

1. 脏读

| 时间  |           事务A           |         事务B          |
| :-: | :---------------------: | :------------------: |
| T1  |          开始事务           |         开始事务         |
| T2  |                         | 修改张三的余额，将余额由100改为200 |
| T3  | 查询张三的余额，结果为100<br>避免了脏读 |                      |
| T4  |                         |        提交了事务         |

当事务A在T3时刻读取zhangsan的余额前，会生成ReadView，由于此时事务B没有提交仍然活跃，因此其事务id一定在ReadView的rw_trx_ids中，因此根据前面介绍的规则，事务B的修改对ReadView不可见。 接下来，事务A根据指针指向的undo log查询上一版本的数据，得到zhangsan的余额为100 balance(余额)。 这样事务A就避免了 dirty read(脏读)。

2. 不可重复读

| 时间  |            事务A             |         事务B          |
| :-: | :------------------------: | :------------------: |
| T1  |            开始事务            |         开始事务         |
| T2  |       查询张三的余额，结果为100       |                      |
| T3  |                            | 修改张三的余额，将余额由100改为200 |
| T4  |                            |        提交了事务         |
| T5  | 查询张三的余额，结果为100<br>避免了不可重复读 |                      |
当事务A在T2时刻读取zhangsan的 balance(余额) 前，会生成ReadView。 此时事务B分两种情况讨论，一种是如图中所示，事务已经开始但没有提交，此时其事务id在ReadView的rw_trx_ids中； 一种是事务B还没有开始，此时其事务id大于等于ReadView的low_limit_id。 无论是哪种情况，根据前面介绍的规则，事务B的修改对ReadView都不可见。

当事务A在T5时刻再次读取zhangsan的余额时，会根据T2时刻生成的ReadView对数据的可见性进行judgment(判断)，从而判断出事务B的修改不可见； 因此事务A根据指针指向的undo log查询上一版本的数据，得到zhangsan的余额为100，从而避免了不可重复 read。

3. 幻读

| 时间  | 事务A                                        | 事务B                         |
| :-: | ------------------------------------------ | --------------------------- |
| T1  | 开始事务                                       | 开始事务                        |
| T2  | 查询0<id<5的所有用户的余额:<br>张三：100（id=1）          |                             |
| T3  |                                            | 账户余额表中插入新用户<br>李四：200（id=2） |
| T4  |                                            | 提交事务                        |
| T5  | 查询0<id<5的所有用户的余额:<br>张三：100（id=1）<br>避免了幻读 |                             
MVCC避免幻读的机制与避免不可重复读非常 analogous(类似)。

当事务A在T2时刻读取0low_limit_id(低界限ID)。 无论是哪种情况，根据前面介绍的规则，事务B的修改对ReadView都不可见。

当事务A在T5时刻再次读取0phantom read(幻读)。