# 背景
之前需求是获取上个月和这个月的利润(需要计算)和活跃用户，我就想要不造一个工厂，传入函数，工厂根据`start~end`做好`group`，然后根据函数的索引，给相对应结果集下的结果增加值。~~我靠，想法非常美好，现实非常骨感。实际测试下来，性能差了很多，两次独立查询`500ms`左右，而工厂函数`2s`左右。~~ 之前是在`clickhouse`中`group`没有指定时间范围，纯纯犯错。实际情况时独立查询`500ms`左右，工厂函数`800ms`左右。


```go
type timeCheckFunc func(*gtime.Time) bool


// getSumProfitAndActUser 计算时间区间内满足条件的天数和总天数

// timeCheckFunc 参数是用于检查某一天是否满足某个条件的函数，可以传入多个函数，返回值 res 切片中对应位置的值表示满足对应函数条件的值

func (*sStats) getSumProfitAndActUser(ctx context.Context, start, end *gtime.Time, funcs ...timeCheckFunc) (sum *mid.ProfitAndActUser, res []mid.ProfitAndActUser, err error) {
    if start == nil || end == nil || start.After(end) {
        err = gerror.New("start time or end time is nil")
        return
    }
    if len(funcs) == 0 {
        res = nil
    } else {
        res = make([]mid.ProfitAndActUser, len(funcs))
    }
    startStr := start.Time.Format(time.DateOnly)
    // endStr := end.Time.Format(time.DateOnly)
    // 实际毛利 = 实际广告收入＋第三方平台结算金额-提现到账金额 - 推广消耗
    // 实际广告收入是手动输入的，且主页上当天的实际毛利收入为0时，当日的毛利也为0。
    // 为了和主页数据相同，返回本月的毛利中需要查询出天数，不能直接计算总和。

  
    // 实际广告收入和推广消耗
    var dailyIncomeAndConsume []struct {
        Date      string  `json:"date"`
        AppId     int     `json:"app_id"`
        Profit    float64 `json:"profit"`
        UseAmount float64 `json:"use_amount"`
    }

    sdaiCols := dao.StatDailyAdIncome.Columns()
    err = dao.StatDailyAdIncome.Ctx(ctx).
        Fields(
            sdaiCols.Date,
            sdaiCols.AppId,
            fmt.Sprintf("sum(%s) as profit", sdaiCols.AdvertActualIncome),
            fmt.Sprintf("sum(%s) as use_amount", sdaiCols.PromotionUseAmount),
        ).
        WhereGTE(dao.StatDailyAdIncome.Columns().Date, startStr).
        Group(sdaiCols.Date, sdaiCols.AppId).
        Scan(&dailyIncomeAndConsume)
    if err != nil {
        g.Log().Errorf(ctx, "[GetDayMonthProfitAndActUser] get StatDailyAdIncome Inconme error: %v", err)
        return
    }

    type dailyAmount struct {
        Date   string  `json:"date"`
        AppId  int     `json:"appId"`
        Amount float64 `json:"amount"`
    }
    var dailyWithdrawal []dailyAmount
    // var monthAndTodayWithdrawal *MonthAndTodayWithdrawal


    // 本月和本日提现到账金额
    woCols := dao.WithdrawalOrder.Columns()
    err = dao.WithdrawalOrder.Ctx(ctx).
        Fields(
            fmt.Sprintf("DATE(%s) as date", woCols.TransferTime),
            woCols.AppId,
            fmt.Sprintf("sum(%s) as amount", woCols.Amount),
        ).
        WhereGTE(woCols.TransferTime, start).
        Where(woCols.OrderState, 2). // orderStatus = 2是已经完成
        Group("date", woCols.AppId).
        Scan(&dailyWithdrawal)
    if err != nil {
        g.Log().Errorf(ctx, "[GetDayMonthProfitAndActUser] get WithdrawalOrder month and today amount error: %v", err)
        return

    }

    // 三方平台收益（悬赏任务平台）

    // 本月和本日平台收益

    // var otherIncome *MonthAndTodayWithdrawal
    roCols := dao.RtOrder.Columns()
    var otherIncome []dailyAmount
    err = dao.RtOrder.Ctx(ctx).
        Fields(
            fmt.Sprintf("DATE(%s) as date", roCols.CreatedAt),
            roCols.AppId,
            fmt.Sprintf("sum(%s) as amount", roCols.Amount),
        ).
        WhereGTE(roCols.CreatedAt, startStr).
        Group("date", roCols.AppId).
        Scan(&otherIncome)
    if err != nil {
        g.Log().Errorf(ctx, "[GetDayMonthProfitAndActUser] get RtOrder month amount error: %v", err)
        return
    }

    sum = new(mid.ProfitAndActUser)
    isExistIncome := make(map[string]struct{}) // date-appId: {} 判断某一天某个app是否有填写实际广告收入
    genExistKey := func(date string, appId int) string {
        return fmt.Sprintf("%s-%d", date, appId)
    }

    // 累加每日的实际广告收入和减去推广消耗，并且标记填写了实际广告收入的日期和应用
    for _, _item := range dailyIncomeAndConsume {
        // 有可能填写了推广消耗，但是没填写实际广告收入。还是以实际广告收入为准
        if _item.Profit != 0 {
            key := genExistKey(_item.Date, _item.AppId)
            isExistIncome[key] = struct{}{}
            sum.Profit += (_item.Profit - _item.UseAmount)
            // 当天的毛利计算
            for i, checkFunc := range funcs {
                if checkFunc != nil && checkFunc(gtime.New(_item.Date)) {
                    res[i].Profit += (_item.Profit - _item.UseAmount)
                }
            }
            // if len(key) >= 10 && key[:10] == endStr {
            //  sum.TodayProfit += (_item.Profit - _item.UseAmount)
            // }
        }
    }
    // 判断日期和应用是存在实际广告收入，存在才减去实际提现金额
    for _, _item := range dailyWithdrawal {
        key := genExistKey(_item.Date, _item.AppId)
        if _, ok := isExistIncome[key]; ok {
            sum.Profit -= (_item.Amount / 100)
            // 当天的毛利计算
            for i, checkFunc := range funcs {
                if checkFunc != nil && checkFunc(gtime.New(_item.Date)) {
                    res[i].Profit -= (_item.Amount / 100)
                }
            }
            // if len(key) >= 10 && key[:10] == endStr {
            //  out.TodayProfit -= (_item.Amount / 100)
            // }
        }
    }
    // 判断日期和应用是存在实际广告收入，存在才加上第三方收益
    for _, _item := range otherIncome {
        key := genExistKey(_item.Date, _item.AppId)
        if _, ok := isExistIncome[key]; ok {
            sum.Profit += (_item.Amount) / 100
            // 当天的毛利计算
            for i, checkFunc := range funcs {
                if checkFunc != nil && checkFunc(gtime.New(_item.Date)) {
                    res[i].Profit += (_item.Amount) / 100
                }
            }
            // if len(key) >= 10 && key[:10] == endStr {
            //  out.TodayProfit += (_item.Amount / 100)
            // }
        }
    }

    // 总活跃用户
    ckConn := ck.GetConn()
    monthActUserSql := `
    select
        COUNT(distinct device_id) as active_users
    from
        account_event
    WHERE account_event.event_type = 0 and account_event.event_type != 1021 AND event_time between ? and ?` // 1021 事件可能是服务器自动的补偿，导致会存在一个用户存在两个设备id的事件记录
    // var monthActUser *ActionUser
    var monthActUser *uint64
    err = ckConn.QueryRow(ctx, monthActUserSql, start.Time.Format(time.DateTime), end.AddDate(0, 0, 1).Add(1*time.Millisecond).Time.Format(time.DateTime)).Scan(&monthActUser)
    if err != nil {
        g.Log().Errorf(ctx, "[GetDayMonthProfitAndActUser] query month active users error: %v", err)
        return
    }
    if monthActUser != nil {
        sum.ActUser = int(*monthActUser)
    }

    // 每日活跃用户
    var dailyActUser []struct {
        Date        string `json:"date" ch:"date"`
        ActiveUsers uint64 `json:"active_users" ch:"active_users"`
    }

    queryActUserSql := `
select
    toString(Date(event_time)) as date,
    COUNT(distinct device_id) as active_users
from
    account_event
WHERE account_event.event_type = 0 and account_event.event_type != 1021
group by date` // 1021 事件可能是服务器自动的补偿，导致会存在一个用户存在两个设备id的事件记录
    err = ckConn.Select(ctx, &dailyActUser, queryActUserSql)
    if err != nil {
        g.Log().Errorf(ctx, "[GetDayMonthProfitAndActUser] query daily actUser err:%v", err)
        return nil, nil, err
    }
    for _, _actUser := range dailyActUser {
        for i, checkFunc := range funcs {
            if checkFunc != nil && checkFunc(gtime.New(_actUser.Date)) {
                res[i].ActUser += int(_actUser.ActiveUsers)
            }
        }
    }
    return sum, res, nil
}
```